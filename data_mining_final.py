# -*- coding: utf-8 -*-
"""Data_Mining_Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18Hw1BJNrcvaFed0-t-ZKmQxFbIv__00G

# **Prediksi penyakit Liver menggunakan Algoritma Decision Tree**
Berikut langkah langkah yang kami lakukan dalam melakukan prediksi penyakit Liver menggunakan Algoritma Decision Tree


1. Menyiapkan library dan dataset yang akan digunakan, dataset yang digunakan disimpan di github agar lebih mudah dalam menggunakannya
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.tree import DecisionTreeClassifier, plot_tree, export_text
from sklearn.model_selection import train_test_split
from sklearn import metrics

df = pd.read_csv('https://raw.githubusercontent.com/enricojoe06/DataMining/main/liver.csv')

df.head()

"""

2. Setelah library dan dataset disiapkan, langkah berikutnya adalah preprosesing data. Dalam preprosesing ini, yang akan dilakukan adalah *encoding* data yaitu merubah jenis kelamin dari tipe string/nominal menjadi float/numerik, *data cleaning* yaitu membersihkan data terutama data yang kosong, dan yang terakhir adalah merubah label yang awalnya adalah 1 sebagai label tidak terkena penyakit dan 2 sebagai label terkena penyakit menjadi 0 dan 1.

"""

df['Dataset'] = df['Dataset'].replace(1, 0)
df['Dataset'] = df['Dataset'].replace(2, 1)

df.isnull().sum()

df = df.dropna()

df['Gender'] = df['Gender'].astype('category').cat.codes.astype('float')

df.head()

"""3. Kemudian, langkah selanjutnya adalah menyiapkan data uji dan data latih. Pertama dataset dipisahkan antara fitur dengan label. Selanjutnya, dataset dibagi menjadi 2 yaitu 75% untuk data latih dan 25% sisanya untuk data uji. Dalam pembagian ini, digunakan parameter *shuffle* bernilai True yang bertujuan untuk mengacak dataset, serta parameter *stratify* untuk membagi dataset agar memiliki komposisi (mean dan standar deviasi) yang sama pada data latih dan data uji"""

y = df[['Dataset']]
x = df.drop(columns = 'Dataset')

x_train, x_test, y_train, y_test = train_test_split(x, y,
                                                    test_size = 0.25,
                                                    shuffle=True, stratify = y)

"""4. Setelah dataset dibagi, selanjutnya adalah pembuatan model. Pembuatan model dilakukan dengan perulangan. Perulangan bertujuan untuk mencoba beberapa tingkat kedalaman pohon yang akan dibuat. Perulangan dilakukan dari kedalaman 1 sampai 10. Dari hasil yang didapatkan kemudian dipilih nilai kedalaman dengan akurasi terbaik untuk digunakan lebih lanjut"""

hasil = []
for i in range(5,11):
  pohon = DecisionTreeClassifier(max_depth = i, random_state = 1)
  pohon.fit(x_train, y_train)
  test_pred_decision_tree = pohon.predict(x_test)
  skor = metrics.accuracy_score(y_test, test_pred_decision_tree)
  hasil.append(skor)

imax = hasil.index(max(hasil))+5
for i,isi in enumerate(hasil):
  print(i+5, '{0:.2f}%'.format(isi*100))
print("Nilai kedalaman dengan akurasi terbaik = ", imax)

"""5. Setelah nilai kedalaman dengan akurasi terbaik didapatkan, selanjutnya adalah perhitungan nilai akurasi, presisi, recall, serta root mean squared error terhadap model dengan menggunakan nilai kedalaman terbaik."""

pohon = DecisionTreeClassifier(max_depth = imax, random_state = 1)
pohon.fit(x_train, y_train)
test_pred_decision_tree = pohon.predict(x_test)

print('Akurasi ',metrics.accuracy_score(y_test, test_pred_decision_tree))
print('Presisi ',metrics.precision_score(y_test, test_pred_decision_tree))
print('Recall ',metrics.recall_score(y_test, test_pred_decision_tree))
print('RMSE ',metrics.mean_squared_error(y_test,test_pred_decision_tree))

"""6. Langkah terakhir adalah visualisasi dari pohon yang dihasilkan. Visualisasi dilakukan dengan 2 cara yaitu dengan menggunakan gambar pohon keputusan dan juga dengan menggunakan teks"""

print(export_text(pohon, feature_names=df.columns[:-1].to_list()))

fig = plt.figure(figsize=(25,20))
_ = plot_tree(pohon, feature_names = df.columns,class_names = [str(0), str(1)], filled=True)

